<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>How To Put 30 Languages Into 1.1MB | Laurenz&#x27;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta
      name="description"
      content="A post about hypher, a fast hyphenation library for Rust. This library converts LaTeX hyphenation patterns into compact finite state machines that can be traversed without any upfront loading. The result is faster and leaner than previous crates."
    />
    <meta property="og:type" content="article" />
    <meta
      property="og:title"
      content="How To Put 30 Languages Into 1.1MB | Laurenz&#x27;s Blog"
    />
    <meta
      property="og:url"
      content="https://laurmaedje.github.io/posts/hypher"
    />
    <meta property="og:site_name" content="Laurenz&#x27;s Blog" />
    <meta
      property="og:description"
      content="A post about hypher, a fast hyphenation library for Rust. This library converts LaTeX hyphenation patterns into compact finite state machines that can be traversed without any upfront loading. The result is faster and leaner than previous crates."
    />
    <link rel="stylesheet" href="/styles.css" />
  </head>
  <body>
    <header>
      <a href="/" class="home">Laurenz&#x27;s Blog</a
      ><a href="https://github.com/laurmaedje" class="social"
        ><img src="/assets/github.png" alt="GitHub" width="32" height="32"
      /></a>
    </header>
    <main>
      <article>
        <h1>How To Put 30 Languages Into 1.1MB</h1>
        <time date="2022-07-23T00:00:00.000Z">July 23, 2022</time>
        <p>
          <em
            >This blog post is about
            <a href="https://github.com/typst/hypher"><code>hypher</code></a
            >, a fast hyphenation library for Rust.</em
          >
        </p>
        <p>
          I’m currently working on a pure-rust LaTeX alternative called
          <a href="https://typst.app">Typst</a>. To obtain justification results
          on par with LaTeX, Typst needs support for hyphenation. A quick search
          on <a href="https://docs.rs">docs.rs</a> showed that there’s only
          really one hyphenation library, fittingly called
          <a href="https://github.com/tapeinosyne/hyphenation"
            ><code>hyphenation</code></a
          >. All other crates I’ve found were small variations of this crate.
          The hyphenation crate has a lot of functionality and supports many
          languages. However, it also has sizable binary overhead when you embed
          the hyphenation patterns (2.8MB). While you can load patterns at
          runtime, distributing the pattern files separately is so much more
          complicated than just embedding them.
        </p>
        <p>
          A specific pain point I had with hyphenation was that I needed to hold
          on to the loaded, heap-allocated language dictionaries. In my case,
          the text was pre-segmented into “words” (string segments between two
          <a href="https://unicode.org/reports/tr14/"
            >Unicode line break opportunities</a
          >) and the language could be different for each word. Thus, I would’ve
          either had to reload the patterns for each word (slow) or set up some
          caching solution. Which is certainly possible, but I had some problems
          getting it to work because the hyphenating iterator kept borrows into
          the caching hash map.
        </p>
        <p>
          So, at this point I decided to build a new crate with the following
          goals: No allocations, no loading at runtime, less binary overhead and
          no dependencies (why not). It looks like this:
        </p>
        <pre><code class="language-rust"><span class="hljs-keyword">use</span> hypher::{hyphenate, Lang};

<span class="hljs-keyword">let</span> <span class="hljs-variable">syllables</span> = <span class="hljs-title function_ invoke__">hyphenate</span>(<span class="hljs-string">&quot;extensive&quot;</span>, Lang::English);
<span class="hljs-built_in">assert_eq!</span>(syllables.<span class="hljs-title function_ invoke__">join</span>(<span class="hljs-string">&quot;-&quot;</span>), <span class="hljs-string">&quot;ex-ten-sive&quot;</span>);
</code></pre>
        <p>(And that’s almost the whole API surface.)</p>
        <h2>Hyphenating words</h2>
        <p>
          So, how do we actually hyphenate stuff? Turns out that there aren’t
          really lists of hyphenated words that are available for free. So even
          with a new, let’s say ML-based algorithm, we lack the data to make it
          work. (Such an approach would definitely be interesting, although I’m
          guessing the models would be quite large.) After a bit of research, it
          seemed that using TeX patterns is still the way to go. TeX patterns
          are, in principle, generated from word lists with the
          <a href="https://ctan.org/pkg/patgen?lang=de">patgen</a> tool, but
          many were tweaked by native speakers over the decades. The algorithms
          for dealing with the patterns go all the way back to Liang’s 1983
          thesis
          <a href="https://tug.org/docs/liang/liang-thesis.pdf"
            ><em>Word Hy-phen-a-tion by Com-put-er</em></a
          >.
        </p>
        <p>
          The general idea of the patterns is the following: There are
          <em>hyphenating</em> and <em>inhibiting</em> patterns. A hyphenating
          pattern says something like “if you see this sequence of letters, you
          can hyphenate here”. An inhibiting pattern is the opposite: “If you
          see this sequence, don’t hyphenate here!” There are multiple levels of
          patterns: The first level of patterns is hyphenating and defines broad
          rules like “you can hyphenate between two successive &#x27;c’s.” The
          second level of patterns is inhibiting and handles exceptions from the
          broad rules. And, you guessed it, the third level is again hyphenating
          and handles the exceptions from the exceptions.
        </p>
        <p>
          The pattern files are encoded in a simple text format: Letters are
          just letters and a number between two letters designates a point of
          hyphenation or inhibition. An odd number specifies a point of
          hyphenation and an even number one of inhibition. This goes up to a
          maximum level of 9. Some pattern include dots to indicate that the
          pattern should only match at the start or end of the word.
        </p>
        <p>
          Now, to find out how to hyphenate a word, we first need a
          zero-initialized array of levels with length one less than that of the
          word (one entry for each point between two letters). Then, we need to
          find all patterns that match a substring of our word and update the
          level array with their levels. Updating always means taking the
          maximum of the existing entry and the number in the pattern, so that
          in the end, we get the result of the strongest pattern. Finally, the
          possible hyphenation points lie at the odd levels in the array. The
          example below illustrates this:
        </p>
        <p>
          <img
            src="/assets/hyphenate.svg"
            alt="Visualization of how to hyphenate the word &#x27;hyphenate&#x27;"
            width="400"
            height="250"
          />
        </p>
        <h2>Tries and state machines</h2>
        <p>
          So far so good. We know the general idea, but an important question
          remains: How do we find all matching patterns? While we could store
          the patterns in a hashmap and iterate over all substrings, this would
          kind of defeat the point of this blog post.
          <em>We want performance.</em>
        </p>
        <p>
          Luckily, Liang’s thesis also contains efficient algorithms to work
          with the patterns. The general idea is to create a <em>trie</em>,
          essentially a tree-shaped finite state machine, to encode the
          patterns. Each path from the root of such a trie to an accepting state
          encodes one pattern. The figure below shows an example for the seven
          patterns from the example above (accepting states have double
          borders). You can see the pattern <code>n2at</code> being reflected by
          the topmost path through the trie. We can easily build such a trie by
          iterating over the patterns, trying to walk each pattern in the trie
          and adding states and transitions as necessary.
        </p>
        <p>
          <img
            src="/assets/state-machine.svg"
            alt="State machine for the seven previously seen patterns"
            width="400"
            height="220"
          />
        </p>
        <p>
          What is still missing from this illustration though is the levels! How
          does that work? Since there is a one-to-one relationship between
          patterns and accepting states, we can simply associate the levels for
          a pattern with the accepting state.
        </p>
        <p>
          In the example above, I have numbered the accepting states with Roman
          numerals so that we can write down the levels for each one. A pattern
          with n letters can have n+1 levels: Before the first letter, between
          each pair of letters and after the last letter. If there isn’t a
          number between two letters, it’s the same as if there was a zero in
          between. This way, we get the following result:
        </p>
        <table>
          <thead>
            <tr>
              <th style="text-align: left">State</th>
              <th style="text-align: left">Pattern</th>
              <th style="text-align: left">Levels</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="text-align: left">I</td>
              <td style="text-align: left"><code>1na</code></td>
              <td style="text-align: left"><code>[1, 0, 0]</code></td>
            </tr>
            <tr>
              <td style="text-align: left">II</td>
              <td style="text-align: left"><code>n2at</code></td>
              <td style="text-align: left"><code>[0, 2, 0, 0]</code></td>
            </tr>
            <tr>
              <td style="text-align: left">III</td>
              <td style="text-align: left"><code>he2n</code></td>
              <td style="text-align: left"><code>[0, 0, 2, 0]</code></td>
            </tr>
            <tr>
              <td style="text-align: left">IV</td>
              <td style="text-align: left"><code>hena4</code></td>
              <td style="text-align: left"><code>[0, 0, 0, 0, 4]</code></td>
            </tr>
            <tr>
              <td style="text-align: left">V</td>
              <td style="text-align: left"><code>hen5at</code></td>
              <td style="text-align: left"><code>[0, 0, 0, 5, 0, 0]</code></td>
            </tr>
            <tr>
              <td style="text-align: left">VI</td>
              <td style="text-align: left"><code>hy3ph</code></td>
              <td style="text-align: left"><code>[0, 0, 3, 0, 0]</code></td>
            </tr>
            <tr>
              <td style="text-align: left">VII</td>
              <td style="text-align: left"><code>4te.</code></td>
              <td style="text-align: left"><code>[4, 0, 0, 0]</code></td>
            </tr>
          </tbody>
        </table>
        <p>
          Now, given a trie with levels, how do we hyphenate a word? We simply
          start a trie walk at each letter of the word and update the level
          array with the levels of each accepting state we meet. This way, we
          once again find all patterns that match any substring in the word, but
          much more efficiently!
        </p>
        <hr />
        <p>
          You can think about tries like this: They allow us to efficiently
          encode <em>shared prefixes</em> of the patterns. But we can even go
          one step further and also profit from <em>shared suffixes.</em> This
          turns the trie into a finite state machine. To do that, we have to
          find <em>ends</em> of walks which are the same. In the example above,
          this would almost work for the two <code>a-t</code> walks ending in
          <code>II</code> and <code>V</code>. However, it unfortunately doesn’t
          in this case because the levels associated with <code>II</code> and
          <code>V</code> are different. For more details on tries, finite state
          machines and suffix compression, read
          <a href="https://blog.burntsushi.net/transducers/"
            >this very interesting blog post.</a
          >
        </p>
        <hr />
        <h2>Encoding state machines compactly</h2>
        <p>
          All that is left to do is to compactly encode our state machine into
          bytes that we can embed into the binary. For this, I took some
          inspiration from
          <a href="https://github.com/BurntSushi/regex-automata"
            ><code>regex-automata</code></a
          >, which makes heavy use of all kinds of automatons.
        </p>
        <p>
          In our case, each state consists of transitions and optionally levels
          for accepting states. For each transition, we have a letter and a
          target state. Well actually, now is maybe a good time to bring up that
          we don’t actually deal with letters. Rather, we build our state
          machine over UTF-8 bytes. This works just as well, but is much easier
          to encode compactly. And when hyphenating, we then of course only
          start trie walks at UTF-8 codepoint boundaries.
        </p>
        <p>
          Back to the states: To encode transitions, we lay out two parallel
          arrays. The first contains each byte for which there is a transition
          and the second contains the <em>address delta</em> to the state we
          should transition into for this byte. Each state has an
          <em>address:</em> its byte offset in the whole encoded machine.
          Transition addresses are always encoded relative to the origin state
          as the delta is often much smaller than the absolute address. To get
          maximum profit out of this, we further use a variable length address
          coding. The address array is either an <code>[i8]</code>,
          <code>[i16]</code> or <code>[i24]</code> depending on the largest
          delta. Overall, a state’s bitstream encoding looks like this:
        </p>
        <p>
          <img
            src="/assets/state-encoding.svg"
            alt="Binary state encoding"
            width="400"
            height="320"
          />
        </p>
        <p>
          Now, the levels. If a state is accepting, it contains an additional
          <em>offset</em> and a <em>length</em> for the levels. The (offset,
          length) pair locates a slice of items in an additional array shared by
          all states. Each item in the level slice corresponds to one number in
          the state’s pattern. A level item consists of two parts: the distance
          of the level from the start of the word or previous level, and the
          level number. We again use the trick of making the distances relative
          to make them smaller. It turns out that there is no relative
          <code>distance</code> larger than 24 and no <code>level</code> larger
          than 9 in the patterns. This means we can cramp both into a single
          byte! We can’t directly shift and bitor these two values into 8 bits
          (distance would need 5 bits and level 4 bits). However, there are
          still only 25 * 10 = 250 combinations, which is less than 256. So we
          can fit it into one byte like this:
        </p>
        <pre><code class="language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">pack</span>(dist: <span class="hljs-type">u8</span>, level: <span class="hljs-type">u8</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u8</span> {
    <span class="hljs-built_in">assert!</span>(dist &lt; <span class="hljs-number">25</span>, <span class="hljs-string">&quot;too high distance&quot;</span>);
    <span class="hljs-built_in">assert!</span>(level &lt; <span class="hljs-number">10</span>, <span class="hljs-string">&quot;too high level&quot;</span>);
    dist * <span class="hljs-number">10</span> + level
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">unpack</span>(packed: <span class="hljs-type">u8</span>) <span class="hljs-punctuation">-&gt;</span> (<span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>) {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">dist</span> = packed / <span class="hljs-number">10</span>;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">level</span> = packed % <span class="hljs-number">10</span>;
    (dist, level)
}
</code></pre>
        <p>
          If the encoded level slice for two states is the same, it is only
          stored once in the shared array, saving even more precious space.
        </p>
        <h2>Finishing up</h2>
        <p>
          At runtime, we now don’t need to prepare or load anything. We can just
          lazily decode the embedded automaton as we’re executing it. And to
          eliminate the last allocation, we can even stack allocate the level
          array if the word isn’t too long (&lt;= 39 bytes in
          <code>hypher</code>).
        </p>
        <p>
          Regarding API, I opted for a free-standing method
          <code>hyphenate(&amp;str, Lang) -&gt; Syllables&lt;&#x27;_&gt;</code>
          as I feel that it is much more discoverable than a method on
          <code>Lang</code>. <code>Syllables</code> is a hand-written iterator
          that segments the string based on the level array. I also always enjoy
          when a crate makes my job as simple as a possible. Therefore, I added
          a <code>join</code> method to <code>Syllables</code> so that you
          quickly add in some (soft) hyphens.
        </p>
        <p>
          The tries are constructed and encoded with a build script. As that
          script really took its time in debug builds, I added this to my
          <code>Cargo.toml</code> to somewhat optimize the process.
        </p>
        <pre><code class="language-toml"><span class="hljs-section">[profile.dev.build-override]</span>
<span class="hljs-attr">opt-level</span> = <span class="hljs-number">1</span>
</code></pre>
        <p>
          Regarding binary size: 1.1MB isn’t that much, but there are also many
          applications where you only want to hyphenate English. For this, I
          added two features <code>full</code> and <code>english</code> with
          <code>full</code> being enabled by default. Dropping
          <code>all</code> and adding <code>english</code> brings the overhead
          down to 27KB. While I don’t think its great to favor English like that
          (I’m not a native English speaker), I also felt that adding one
          feature per language didn’t carry its weight.
        </p>
        <pre><code class="language-toml"><span class="hljs-section">[features]</span>
<span class="hljs-attr">default</span> = [<span class="hljs-string">&quot;full&quot;</span>]
<span class="hljs-attr">full</span> = [<span class="hljs-string">&quot;english&quot;</span>]
<span class="hljs-attr">english</span> = []
</code></pre>
        <p>
          (Update:
          <a href="https://github.com/typst/hypher/pull/3"
            >There’s now one feature per language.</a
          >)
        </p>
        <h2>Benchmarks</h2>
        <p>
          Now, let’s very briefly compare
          <a href="https://github.com/typst/hypher"><code>hypher</code></a> with
          <a href="https://github.com/tapeinosyne/hyphenation"
            ><code>hyphenation</code></a
          >.
        </p>
        <table>
          <thead>
            <tr>
              <th style="text-align: left">Task</th>
              <th style="text-align: right">hypher</th>
              <th style="text-align: right">hyphenation</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="text-align: left">
                Hyphenating <code>extensive</code> (english)
              </td>
              <td style="text-align: right">356ns</td>
              <td style="text-align: right">698ns</td>
            </tr>
            <tr>
              <td style="text-align: left">
                Hyphenating <code>διαμερίσματα</code> (greek)
              </td>
              <td style="text-align: right">503ns</td>
              <td style="text-align: right">1121ns</td>
            </tr>
            <tr>
              <td style="text-align: left">Loading the english patterns</td>
              <td style="text-align: right">0us</td>
              <td style="text-align: right">151us</td>
            </tr>
            <tr>
              <td style="text-align: left">Loading the greek patterns</td>
              <td style="text-align: right">0us</td>
              <td style="text-align: right">0.826us</td>
            </tr>
          </tbody>
        </table>
        <p>
          For these two test cases, hypher is about 2x as fast as hyphenation.
          Moreover, the loading overhead of hyphenation is quite large in
          comparison to hyphenating a single word, at least for English. All
          benchmarks were executed on ARM, Apple M1.
        </p>
        <p>
          The direct overhead of embedding is ~1.1MB for hypher and ~2.8 MB for
          hyphenation. However, this comparison is unfair to hyphenation as I
          dropped some languages from hypher. Over the decades, quite a lot of
          TeX pattern files have amassed. For many of these, I couldn’t even
          find any evidence that hyphenation is used for these languages, so I
          removed them. Furthermore, I wanted <code>hypher</code> to be
          permissively licensed. Therefore, it unfortunately does not support
          languages for which the only available patterns have GPL-like
          licenses. There are a few of those, but not too many. In a fairer
          comparison where only the common languages are considered, hypher’s
          encoding is still ~12% more compact than hyphenation’s.
        </p>
        <p>
          That’s it, thank you for reading! Also,
          <a href="https://typst.app">take a look at Typst</a> if you’re
          interested.
        </p>
        <p>
          Discussion on
          <a
            href="https://www.reddit.com/r/rust/comments/w683br/how_to_put_30_languages_into_11mb/"
            >r/rust</a
          >.
        </p>
      </article>
    </main>
  </body>
</html>
