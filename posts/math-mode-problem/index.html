<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>The Math Mode Problem | Laurenz&#x27;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta
      name="description"
      content="Typst&#x27;s math mode has a strange precedence problem that most people using it will run into at some point.
"
    />
    <meta property="og:type" content="article" />
    <meta
      property="og:title"
      content="The Math Mode Problem | Laurenz&#x27;s Blog"
    />
    <meta
      property="og:url"
      content="https://laurmaedje.github.io/posts/math-mode-problem"
    />
    <meta property="og:site_name" content="Laurenz&#x27;s Blog" />
    <meta
      property="og:description"
      content="Typst&#x27;s math mode has a strange precedence problem that most people using it will run into at some point.
"
    />
    <link rel="stylesheet" href="/styles.css" />
  </head>
  <body>
    <header>
      <a href="/" class="home">Laurenz&#x27;s Blog</a
      ><a href="https://github.com/laurmaedje" class="social"
        ><img src="/assets/github.png" alt="GitHub" width="32" height="32"
      /></a>
    </header>
    <main>
      <article>
        <h1>The Math Mode Problem</h1>
        <time datetime="2025-07-07T00:00:00.000Z">July 7, 2025</time>
        <p>
          Typst’s math mode has a strange problem that most people using it will
          run into at some point: If you write <code>f_i(x)</code>, you will get
          <code>i(x)</code> as the subscript instead of just <code>i</code> as
          you might expect. To fix it, you need to write <code>f_i (x)</code>.
          Why is this?
        </p>
        <p>
          Let’s look at a slightly more interesting example:
          <code>f^pi(x)</code>. You’d probably still expect just
          <code>pi</code> to be the superscript (but it’s still the full
          <code>pi(x)</code>). But we’re getting closer. Consider this now:
          <code>e^abs(x)</code>. Here, it’s now quite clear that we want the
          absolute value of <code>x</code> as the superscript. For a human,
          that’s obvious. But for the machine, or more specifically, Typst’s
          parser, the second and third example look the same.
        </p>
        <p>
          Only later, when Typst is evaluating this equation and all the code
          above it has run, it realizes that <code>abs</code> is a Typst
          function and <code>pi</code> is a symbol. At that point, it’s a bit
          late for reconsidering the syntactical structure of the equation. To
          make the <code>abs(x)</code> function call work properly, function
          calls bind more tightly than sub- and superscripts. As a side effect,
          <code>f^pi(x)</code> renders like it does.
        </p>
        <p>
          It’s questionable whether making this <code>abs(x)</code> call work is
          worth making the precedence for sub- and superscripts so unintuitive.
          And, in fact, in Typst 0.3 and below the situation was reversed: Sub-
          and superscripts worked intuitively, but <code>abs(x)</code> silently
          didn’t work. This was changed in a community pull request and, at the
          time, things were moving so fast that we didn’t quite realize the
          impact this change would have.
        </p>
        <p>
          Since then, there has been discussion about either going back or
          finding some solution that somehow makes both work properly. This sort
          of kept stalling and now we’re at a point where we really gotta make
          up our mind. In fact, a
          <a href="https://github.com/typst/typst/pull/6442">PR</a> is open
          right now to simply revert to the Typst 0.3 behavior. This would
          silently change the rendering of a fair amount of documents, but it
          might just be a band aid we must rip off.
        </p>
        <p>
          While pondering over this PR, I took one last delve into the topic,
          trying to make sense of what’s what. This blog post is the result of
          this and should serve as a synthesis of the discussions we’ve had so
          far. If you dive into the history, you can find a lot of discussions
          on the topic spread out over the
          <a
            href="https://discord.com/channels/1054443721975922748/1176478139757629563"
            >Math forge</a
          >
          on our Discord server. I’ve extracted links to all the points where
          discussion was happening in the forge, so if you want to peruse them,
          here you go:
          <a
            href="https://discord.com/channels/1054443721975922748/1176478139757629563/1249499077721460887"
            >1</a
          >,
          <a
            href="https://discord.com/channels/1054443721975922748/1176478139757629563/1277759050456760332"
            >2</a
          >,
          <a
            href="https://discord.com/channels/1054443721975922748/1176478139757629563/1297121034209722371"
            >3</a
          >,
          <a
            href="https://discord.com/channels/1054443721975922748/1176478139757629563/1319188154162348063"
            >4</a
          >,
          <a
            href="https://discord.com/channels/1054443721975922748/1176478139757629563/1325480762161631273"
            >5</a
          >,
          <a
            href="https://discord.com/channels/1054443721975922748/1176478139757629563/1353663985706340413"
            >6</a
          >.
        </p>
        <h2>The root cause</h2>
        <p>
          Attachments (i.e. sub- and superscripts) are the point where most
          people get into contact with the problem presented above. But it is
          not actually the root cause. The root cause are
          <em>function calls.</em> If I write an identifier followed by a
          parenthesis in Typst’s math mode, there is some inherent ambiguity.
          There are, in fact, <em>three</em> possible options what I could have
          meant and all would ideally imply slightly different precedence rules.
        </p>
        <ol>
          <li>A Typst function call like <code>abs(x + y)</code></li>
          <li>
            Evaluation of a function in the mathematical sense:
            <code>f(x + y)</code>, <code>omega(x + y)</code>
          </li>
          <li>
            A space-less implied multiplication: <code>a(2 + b)</code>,
            <code>lambda(2 + b)</code>
          </li>
        </ol>
        <p>
          The first always requires a multi-letter identifier while the latter
          two can be single- or multi-letter.
        </p>
        <p>
          Crucially, <code>abs(x + y)</code> and <code>omega(x + y)</code> look
          exactly the same for Typst and are also parsed just the same. You can
          also observe that <code>omega(x + y)</code> is highlighted blue like a
          function call in the web app even though it is not a Typst function.
          Only at runtime, while Typst is processing the equation, it realizes
          that <code>omega</code> is actually a symbol. Then, in a sort of
          best-effort way, it tries to turn the thing it parsed as an argument
          list back into content. Most people never notice this, but it’s
          possible to observe it by adding a named argument to the
          <code>omega</code> call (which is just silently omitted in 0.13.1,
          which is fixed on main). The “unparsing” mostly just works, but is a
          bit of a hack and illustrates that the ambiguity goes deeper than just
          attachments.
        </p>
        <p>
          Why do we observe it primarily with attachments then? Because they are
          subject to precedence rules and, compared to the precedence of an
          attachment, the precedence of a Typst function should be different
          than the one of a mathematical function. In <code>e^abs(x)</code>, we
          want the Typst function call to bind more tightly (= higher
          precedence) than the <code>^</code> operator, i.e.
          <code>e^(abs(x))</code> (because <code>(e^abs)(x)</code> simply does
          not make sense). In <code>e^omega(x)</code>, we want the attachment to
          bind more tightly than the math function evaluation, i.e.
          <code>(e^omega)(x)</code>.
        </p>
        <p>
          A related situation exists for fractions: In <code>1/f(a+b)</code>, a
          human reader might expect the fraction to bind less tightly that the
          function evaluation, i.e. <code>1/(f(a+b))</code>. But this is just
          because of my choice of letters. If I write <code>1/x(a+b)</code>,
          you’d probably read that as <code>1/x (a+b)</code>. In previous
          discussions, this ambiguity with fractions has been brought up as
          being closely related to the attachment problem. I want to argue that
          these are different concerns. For attachments, we have a problem
          because Typst functions and math functions should have different
          precedence compared to attachments. Meanwhile, I’d argue, it’s okay
          that both math functions and Typst functions have the same precedence
          compared to fractions. The ambiguity exists even
          <em>without Typst functions</em> being involved.
        </p>
        <p>
          In my opinion, writing <code>1/x (a+b)</code> instead of
          <code>1/x(a+b)</code>, and having <code>f(x)/g(x)</code> work properly
          in exchange, is a good trade-off and <em>consistent</em> with the rest
          of Typst. The thing is, Typst kind of has syntax for implied
          multiplication: A space. It’s also necessary if you write
          <code>a b</code>. It just happens that you can omit it in some cases
          like <code>2a</code> or <code>a(b+c)</code>. But in
          <code>1/x(a+b)</code> you can’t. There’s also no way to resolve the
          ambiguity with runtime information, you fundamentally need to
          distinguish on a syntactical level and that’s exactly what the space
          is doing. Of course, you could require the opposite (i.e.
          <code>1/(x(a+b))</code>), but I’m not convinced it’s better. We
          already have the concept of a space being needed for implied
          multiplication, so the current behavior is quite consistent. And
          requiring these parentheses would make many equations quite a bit
          noisier to write.
        </p>
        <p>
          There is one more interesting case, which I’d like to highlight
          because it got so little attention in the previous discussions: Text
          operators. If I write <code>e^sin(x)</code>, then a human reader
          parses this as <code>e^(sin(x))</code>, so it should bind more tightly
          than an attachment. Again, no Typst function is involved. Note that
          <code>sin</code> is not a function in Typst though: You can also write
          just <code>sin x</code>. It’s just some content which can happen to
          stand before parentheses, just like <code>omega</code>. So even
          ignoring Typst functions, there is ambiguity in whether mathematical
          function evaluation should have higher or lower precedence than
          attachments.
        </p>
        <p>
          To summarize, ideally we’d like to have the following hierarchy of
          precedence (from tightest to least tightly binding):
        </p>
        <ol>
          <li>Typst function</li>
          <li>Operator function like <code>sin</code></li>
          <li>Attachment</li>
          <li>Typical function evaluation in the mathematical sense</li>
          <li>Fraction</li>
          <li>Implied multiplication (without a space)</li>
        </ol>
        <p>But we can’t because 1, 2, 4, and 6 all have the same syntax!</p>
        <h2>Our options</h2>
        <p>What options do we have to deal with this situation?</p>
        <h3>A: Do nothing</h3>
        <p>We can keep everything as-is.</p>
        <h3>B: Revert to Typst 0.3 behavior</h3>
        <p>
          We can revert to the behavior of Typst 0.3 and below. This would mean
          that <code>f_i(x)</code> renders as expected. However, we would break
          <code>e^abs(x)</code>, which would need to be written as
          <code>e^(abs(x))</code>. We also won’t get rid of the wonkyness of
          “unparsing” an argument list back into math content because we don’t
          know whether <code>pi(1 + 2)</code> is a function call or just
          <code>pi</code> multiplied by three.
        </p>
        <h3>C: Runtime parsing</h3>
        <p>
          One option that was discussed and prototyped by
          <a href="https://github.com/wrzian">@wrzian</a> was to reduce the
          amount of parsing done during the initial parsing stage to just
          tokenizing the equation and then doing the actual parsing at runtime,
          when we know whether something is a function or a symbol. This would
          allow us to fix the attachment problem with runtime information. It
          would also fix the problem of having to unparse math argument lists.
        </p>
        <h3>D: <code>MathAttachCall</code></h3>
        <p>
          We could have normal parsing, but add a new expression kind that
          describes a mix of an attachment and a function call (i.e.
          <code>e^abs(x)</code> becoming
          <code>MathAttachCall(e, abs, x)</code>). This would allow us to decide
          at runtime whether we want to use the attachment or function call
          option. This is a much more lightweight alternative to runtime parsing
          that fixes the precedence problem, but doesn’t touch the “unparsing”
          of argument lists.
        </p>
        <h3>E: Different syntax for Typst function calls in math</h3>
        <p>
          As a final option, we could resolve the ambiguity by introducing new
          syntax for Typst function calls in math. A natural choice, for
          instance, would be to require a hash in front of a function call (note
          this would imply the need for further syntactical changes to argument
          lists). Now you might say
        </p>
        <blockquote>
          <p>
            Wait… Are you just ditching Typst’s math mode main characteristic
            compared to LaTeX? If I have to write hashes everywhere instead of
            backslashes, what did I win in the first place?
          </p>
        </blockquote>
        <p>
          But a realization I had is that there might be a middle ground if we
          only require a hash for functions, not for plain variables (typically
          symbols).
        </p>
        <p>
          LaTeX requires backslashes for every macro. That includes macros with
          and without arguments. And there are much more of the latter than of
          the former. In one math thesis I analyzed (I know, it’s a very small
          sample), the ratio of identifiers which would then need a hash to
          those that still wouldn’t was roughly one to nine.
        </p>
        <h2>Discussion</h2>
        <p>
          You now have an overview over all options that were brought up over
          time. Next, I’d like to discuss my view on the situation and argue for
          one particular option. I should note that my view has shifted across
          different options over the past weeks, but I am now relatively settled
          in my opinion.
        </p>
        <p>
          First of all, to get it out of the way: I don’t think option A is
          viable because the behavior of <code>f_i(x)</code> is just way too
          unintuitive and counter to people’s expectations. It’s the complaint
          about Typst’s math mode I hear most often (aside from diverging from
          LaTeX in the first place, but that mostly comes from people that
          haven’t really tested it as far as I can tell).
        </p>
        <p>
          Option B is the simplest one. It trades something that currently works
          away in exchange for making something work that doesn’t work right now
          (with the thing that currently doesn’t work being much more common).
          Meanwhile, options C and D try to be smart about it and somehow get
          the best of both worlds. This comes with costs though: It makes it
          harder for tooling (think syntax highlighters and IDEs) to reason
          about your equations, and to an extent, also for humans. And it makes
          Typst math less portable as a format in my opinion, reducing the
          chances of third parties adopting it; as it requires tighter
          integration with the evaluation model.
        </p>
        <p>
          For full runtime parsing, those concerns are quite large in my
          opinion. For the <code>MathAttachCall</code> a bit less so. What’s so
          bad about a bit of compiler trickery and smartness to make it “just
          work?” That, at least, was my opinion for the past week. But then I
          took another look at the special case of <code>e^sin(x)</code> and I
          think it’s an important case to look at. It’s sort of a morph between
          <code>e^pi(x)</code> and <code>e^abs(x)</code>. Is
          <code>sin</code> more like a symbol or a function? Even though here
          it’s clear what the precedence should be, it shows that the line
          between Typst functions and math functions is fuzzy. Our whole goal
          with C and D is to somehow manage to have different precedence for
          Typst vs. math functions. But if we can’t even say for sure what is a
          Typst and a math function, won’t that cause more confusion than it
          resolves?
        </p>
        <p>
          I think solution E demonstrates this even better: If I write
          <code>omega(x)</code>, but <code>#abs(x)</code>, should I write
          <code>sin(x)</code> or <code>#sin(x)</code>? I don’t know, it could be
          either. What about a custom user-defined definition. Should it be used
          as an identifier or called as a function? The thing is,
          <em>users don’t really need to care</em> whether something is a math
          function or a Typst function. All they need to know is: One or
          multiple letters followed by a parenthesis is considered a function
          call by Typst, be it a Typst scripting call or a mathematical one. And
          to me, that implies that both should have the same precedence level,
          to keep things predictable.
        </p>
        <p>
          This also means that you can consistently reason about precedence in
          equations of a field you’re unfamiliar with, where you’re unsure
          whether something is a symbol or a custom function. You just need to
          know: Blue highlighting = function call. Syntax highlighting
          <em>helps</em> you instead of tricking you just because the
          highlighter has no access to runtime information.
        </p>
        <p>
          I am thus now of the strong opinion that option B is the way to go.
          It’s not too bad to have to write <code>e^(abs(x))</code> with
          parentheses and it’s easy to produce a warning for
          <code>e^abs(x)</code>. There is currently
          <a href="https://github.com/typst/typst/pull/6442"
            >a PR open that implements option B</a
          >. I’m still open for further discussion and want to give people some
          time to respond to this post, should they wish so, but if nothing big
          comes up, I plan to merge this PR next week.
        </p>
      </article>
    </main>
  </body>
</html>
