<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Frozen State | Laurenz&#x27;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta
      name="description"
      content="Freezing state in Typst and how it could tie in with the context idea."
    />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="Frozen State | Laurenz&#x27;s Blog" />
    <meta
      property="og:url"
      content="https://laurmaedje.github.io/posts/frozen-state"
    />
    <meta property="og:site_name" content="Laurenz&#x27;s Blog" />
    <meta
      property="og:description"
      content="Freezing state in Typst and how it could tie in with the context idea."
    />
    <link rel="stylesheet" href="/styles.css" />
  </head>
  <body>
    <header>
      <a href="/" class="home">Laurenz&#x27;s Blog</a
      ><a href="https://github.com/laurmaedje" class="social"
        ><img src="/assets/github.png" alt="GitHub" width="32" height="32"
      /></a>
    </header>
    <main>
      <article>
        <h1>Frozen State</h1>
        <time date="2023-12-12T00:00:00.000Z">December 12, 2023</time>
        <p>
          One thing that comes up from time to time, especially in the context
          of slide creation, is the idea of <em>freezing</em> state. Consider
          the following slide snippet written using the Polylux package:
        </p>
        <pre><code><span class="typ-key">#</span><span class="typ-key">import</span> <span class="typ-str">&quot;@preview/polylux:0.3.1&quot;</span><span class="typ-punct">:</span> <span class="typ-op">*</span>
<span class="typ-key">#</span><span class="typ-key">set</span> math<span class="typ-punct">.</span><span class="typ-func">equation</span><span class="typ-punct">(</span>numbering<span class="typ-punct">:</span> <span class="typ-str">&quot;(1)&quot;</span><span class="typ-punct">)</span>

<span class="typ-func">#</span><span class="typ-func">polylux-slide</span><span class="typ-punct">[</span>
  First, we show: <span class="typ-pol">#</span><span class="typ-pol">pause</span>
  <span class="typ-math-delim">$</span> x + y = z <span class="typ-math-delim">$</span>   <span class="typ-pol">#</span><span class="typ-pol">pause</span>
  Then, we continue.
<span class="typ-punct">]</span>
</code></pre>
        <p>
          Here, we make use of the <code>pause</code> command to generate
          multiple pages, each of which uncovers more of the slide. If you
          compile these slides, you’ll see that the equation is numbered with
          (2) on page 2 and with (3) on page 3. This is of course not what we
          want.
        </p>
        <p>
          To understand why it happens, we have to understand a bit of how
          Polylux works internally: When you use the pause feature, Polylux
          figures out how many pages in total your slide needs. It then
          generates this number of pages and inserts the full content on each
          page, but with rules configured that conditionally
          <a href="https://typst.app/docs/reference/layout/hide/"
            ><code>#hide</code></a
          >
          parts of the content.
        </p>
        <p>
          From Typst’s point of view, Polylux generates three separate equations
          and hides one of them. Reasonably, it thus gives each of those
          equations a separate number. Note that this is <em>generally</em> a
          desirable property: If you store content in a variable and use it
          multiple times, you get the same result as if you’d have written the
          content in each of the places (this is called
          <em>referential transparency</em>). This makes things composable and
          allows packages to juggle content around and style it “after the
          fact”. It’s just in some cases like this one that it’s actually
          semantically the same content, and we need some way to express that in
          Typst.
        </p>
        <h2>Measurement and introspection</h2>
        <p>
          What I’ve only realized recently, is that a very similar requirement
          arises when we <code>measure</code> content that performs
          introspection. Consider the following snippet:
        </p>
        <pre><code><span class="typ-key">#</span><span class="typ-key">let</span> c <span class="typ-op">=</span> <span class="typ-func">counter</span><span class="typ-punct">(</span><span class="typ-str">&quot;key&quot;</span><span class="typ-punct">)</span>
<span class="typ-pol">#</span><span class="typ-pol">c</span><span class="typ-punct">.</span><span class="typ-func">update</span><span class="typ-punct">(</span><span class="typ-num">1</span><span class="typ-punct">)</span>
<span class="typ-func">#</span><span class="typ-func">style</span><span class="typ-punct">(</span>styles <span class="typ-op">=&gt;</span> <span class="typ-punct">{</span>
  <span class="typ-key">let</span> elem <span class="typ-op">=</span> c<span class="typ-punct">.</span><span class="typ-func">display</span><span class="typ-punct">(</span>n <span class="typ-op">=&gt;</span> n <span class="typ-op">*</span> <span class="typ-func">v</span><span class="typ-punct">(</span><span class="typ-num">10pt</span><span class="typ-punct">)</span><span class="typ-punct">)</span>
  <span class="typ-key">let</span> height <span class="typ-op">=</span> <span class="typ-func">measure</span><span class="typ-punct">(</span>elem<span class="typ-punct">,</span> styles<span class="typ-punct">)</span><span class="typ-punct">.</span>height
  <span class="typ-punct">[</span>Height is <span class="typ-pol">#</span><span class="typ-pol">height</span><span class="typ-punct">]</span>
  c<span class="typ-punct">.</span><span class="typ-func">step</span><span class="typ-punct">(</span><span class="typ-punct">)</span>
  elem <span class="typ-comment">// try moving or deleting this</span>
<span class="typ-punct">}</span><span class="typ-punct">)</span>
<span class="typ-pol">#</span><span class="typ-pol">c</span><span class="typ-punct">.</span><span class="typ-func">step</span><span class="typ-punct">(</span><span class="typ-punct">)</span>
</code></pre>
        <p>
          As-is, this outputs <code>20pt</code> which means <code>n</code> was
          <code>2</code>. If you delete the line with <code>elem</code>, it
          suddenly outputs <code>30pt</code>. What is happening here?
        </p>
        <p>
          It turns out that measuring in combination with introspection features
          yields some interesting results. To understand what is happening here,
          we first need to understand how counters work internally. Since Typst
          doesn’t allow for side effects, counters and state use a trick: All
          mutations and displays of counters are invisible content that ends up
          somewhere in the document and thus in the final layout. When resolving
          a <code>.display</code> call, the counter type goes ahead and queries
          (as in
          <a href="https://typst.app/docs/reference/introspection/query/"
            ><code>query</code></a
          >) for all counter updates in the document <em>before</em> the
          display’s location. This is just like a query for all headings before
          a specific point as counter updates are content like headings, just
          invisible.
        </p>
        <p>
          Given this complete sequence of updates, we can then determine the
          value at the current location by applying the updates one by one. For
          example if we have a series of updates <code>.update(2)</code>,
          <code>update(n =&gt; 3 * n)</code>,
          <code>update(n =&gt; n - 3)</code>, <code>update(5)</code>, it
          computes the sequence <code>2, 6, 3, 5</code>. If the determined
          location of a display call is between the first two updates, it yields
          <code>2</code>. Similarly, if it is between the last two updates, it
          yields <code>3</code>. The results thus depend on how Typst determines
          whether an update is before or after our display when doing the query.
        </p>
        <p>
          So, how does it work? The implementation is actually relatively
          straight-forward: Typst’s introspection system holds an ordered list
          of all locatable elements. When doing a “before” query, it finds the
          index of the cutoff element in the list and extracts all matches up to
          this index. Crucially, asking for all matches before a non-existent
          element will just give us all matches.
        </p>
        <p>
          Equipped with this knowledge, let’s look at what happens above.
          Clearly, the <code>measure</code> call is affected by the position of
          <code>elem</code> in the real layout:
        </p>
        <ul>
          <li>
            If the <code>elem</code> is after the first <code>c.step()</code>,
            we get that one as part of our update list, yielding
            <code>20pt</code>
          </li>
          <li>
            If <code>elem</code> is deleted, we don’t find it at all and get all
            counter updates, yielding <code>30pt</code>
          </li>
          <li>
            If <code>elem</code> is moved above the first <code>c.step()</code>,
            we only get the initial update, yielding <code>10pt</code>
          </li>
        </ul>
        <p>
          The reason the measurement is affected by the real layout is that the
          locations (= unique element IDs) assigned to <code>elem</code> during
          measurement and real layout match up. This is typically what you want
          because you’re measuring something to determine how to arrange it in a
          layout of your own. However, it can yield surprising results if you
          don’t end up putting the measured thing into the document. It is also
          fundamentally a best-effort approach because Typst can’t always
          disambiguate how multiple measured elements map to multiple real
          elements (if multiple ones have the same hash). Doing current way we
          do measurements on things with introspection is sadly a bit
          ill-defined. So far, it mostly worked out because the IDs happen to
          mostly match up in the current implementation.
        </p>
        <p>
          Unfortunately, the current implementation requires some mutable state
          in the layout engine. If we can get rid of this state, it becomes
          <em>trivial</em> to parallelize the layout engine. There is an idea
          for a new approach to assigning these IDs, but in this new approach,
          the IDs between measured elements and real layouts unfortunately don’t
          match up at all in many cases. This leads to unsatisfying measurement
          results whenever introspection is involved. Without any further
          changes, counters would almost always have their final state and
          citations wouldn’t work at all. (Citation formatting is fundamentally
          a stateful and global thing, so it must be done on all citations at
          once. It relies on being able to query for the citations.)
        </p>
        <h2>What now?</h2>
        <p>
          Since the existing approach results in some strange measurements
          results (which can fundamentally only be dealt with on a best-effort
          basis) and the new approach can’t properly handle measurement at all,
          maybe the problem lies with the measurement API itself. Maybe
          redesigning this API will make our problems go away. What we need is a
          way to somehow assign a unique ID to content <em>before</em> measuring
          it so that the desired link between measured elements and the final
          layout is clear to both users / package authors and Typst.
        </p>
        <p>
          Getting a unique ID in a pure language is somewhat tricky, but this is
          where the <a href="/posts/types-and-context/">context</a> idea comes
          in again. Since measurement needs to happen within a style callback /
          context anyway, we can leverage that context to get most of our
          desired uniqueness (a context in itself always gets a unique ID). We
          can get further uniqueness from the call-site syntax span and content
          hash where we assign the ID. There is still the possibility for a
          collision when dealing with hash-equal content in a loop. This would
          require manual disambiguation by the caller (very similar to the plan
          for
          <a href="https://github.com/typst/typst/issues/2425"
            >anonymous states</a
          >), but it would be a very rare occurrence.
        </p>
        <p>
          And how do we name the function that does this content wrapping? This
          is where the circle closes! By assigning a unique ID to the content,
          we tell Typst: “This is the same content no matter where you see it.
          If it uses counters and state internally, resolve all of them in the
          same way everywhere.”
        </p>
        <p>
          Sound familiar? This is exactly what we need for the Polylux example
          from above. Once we <code>freeze</code> content, we can also put it
          into the document multiple times and have it be the same every time:
        </p>
        <pre><code><span class="typ-key">#</span><span class="typ-key">set</span> math<span class="typ-punct">.</span><span class="typ-func">equation</span><span class="typ-punct">(</span>numbering<span class="typ-punct">:</span> <span class="typ-str">&quot;(1)&quot;</span><span class="typ-punct">)</span>
<span class="typ-key">#</span><span class="typ-key">context</span> <span class="typ-punct">{</span>
  <span class="typ-key">let</span> v <span class="typ-op">=</span> <span class="typ-func">freeze</span><span class="typ-punct">(</span><span class="typ-math-delim">$</span> x + y = z <span class="typ-math-delim">$</span><span class="typ-punct">)</span>
  v <span class="typ-comment">// this will be equation (1)</span>
  v <span class="typ-comment">// and this, too :)</span>
<span class="typ-punct">}</span>
</code></pre>
        <p>
          In the same way, we can measure it and Typst will always understand
          the link between the measured and real content:
        </p>
        <pre><code><span class="typ-key">#</span><span class="typ-key">context</span> <span class="typ-punct">{</span>
  <span class="typ-key">let</span> v <span class="typ-op">=</span> <span class="typ-func">freeze</span><span class="typ-punct">(</span>content<span class="typ-punct">)</span>
  <span class="typ-comment">// No matter what happens, the</span>
  <span class="typ-comment">// measurement will observe state</span>
  <span class="typ-comment">// like `v` does below.</span>
  <span class="typ-key">let</span> size <span class="typ-op">=</span> <span class="typ-func">measure</span><span class="typ-punct">(</span>v<span class="typ-punct">)</span>
  v
<span class="typ-punct">}</span>
</code></pre>
        <p>
          Note that this is an idea I literally had today, so there might be
          some huge problem with it, I’m not yet seeing. But it felt like a step
          forward, so I thought I’d share it.
        </p>
      </article>
    </main>
  </body>
</html>
